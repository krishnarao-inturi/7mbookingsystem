["^ ","~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$re-frame.interceptor","~:imports",null,"~:requires",["^ ","~$re-frame.interop","^7","~$re-frame.loggers","^8"],"~:uses",["^ ","~$console","^8","~$ratom?","^7","~$empty-queue","^7","~$debug-enabled?","^7"],"~:defs",["^ ","~$invoke-interceptors",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","~:line",72,"~:column",8,"~:end-line",72,"~:end-column",27,"~:private",true,"~:arglists",["~#list",["~$quote",["^I",[["~$context","~$direction"]]]]],"~:doc","Loop over all interceptors, calling `direction` function on each,\n  threading the value of `context` through every call.\n\n  `direction` is one of `:before` or `:after`.\n\n  Each iteration, the next interceptor to process is obtained from\n  context's `:queue`. After they are processed, interceptors are popped\n  from `:queue` and added to `:stack`.\n\n  After sufficient iteration, `:queue` will be empty, and `:stack` will\n  contain all interceptors processed.\n\n  Returns updated `context`. Ie. the `context` which has been threaded\n  through all interceptor functions.\n\n  Generally speaking, an interceptor's `:before` fucntion will (if present)\n  add to a `context's` `:coeffect`, while it's `:after` function\n  will modify the `context`'s `:effect`.  Very approximately.\n\n  But because all interceptor functions are given `context`, and can\n  return a modified version of it, the way is clear for an interceptor\n  to introspect the stack or queue, or even modify the queue\n  (add new interceptors via `enqueue`?). This is a very fluid arrangement."],"^G",true,"^3","~$re-frame.interceptor/invoke-interceptors","~:variadic",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",27,"~:method-params",["^I",[["^K","^L"]]],"~:protocol-impl",null,"~:arglists-meta",["^I",[null,null]],"^D",1,"^C",72,"^E",72,"~:max-fixed-arity",2,"~:fn-var",true,"^H",["^I",["^J",["^I",[["^K","^L"]]]]],"^M","Loop over all interceptors, calling `direction` function on each,\n  threading the value of `context` through every call.\n\n  `direction` is one of `:before` or `:after`.\n\n  Each iteration, the next interceptor to process is obtained from\n  context's `:queue`. After they are processed, interceptors are popped\n  from `:queue` and added to `:stack`.\n\n  After sufficient iteration, `:queue` will be empty, and `:stack` will\n  contain all interceptors processed.\n\n  Returns updated `context`. Ie. the `context` which has been threaded\n  through all interceptor functions.\n\n  Generally speaking, an interceptor's `:before` fucntion will (if present)\n  add to a `context's` `:coeffect`, while it's `:after` function\n  will modify the `context`'s `:effect`.  Very approximately.\n\n  But because all interceptor functions are given `context`, and can\n  return a modified version of it, the way is clear for an interceptor\n  to introspect the stack or queue, or even modify the queue\n  (add new interceptors via `enqueue`?). This is a very fluid arrangement."],"~$assoc-coeffect",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",58,"^D",7,"^E",58,"^F",21,"^H",["^I",["^J",["^I",[["^K","~$key","~$value"]]]]]],"^3","~$re-frame.interceptor/assoc-coeffect","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",21,"^P",["^I",[["^K","^V","^W"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",58,"^E",58,"^S",3,"^T",true,"^H",["^I",["^J",["^I",[["^K","^V","^W"]]]]]],"~$invoke-interceptor-fn",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",65,"^D",8,"^E",65,"^F",29,"^G",true,"^H",["^I",["^J",["^I",[["^K","~$interceptor","^L"]]]]]],"^G",true,"^3","~$re-frame.interceptor/invoke-interceptor-fn","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",29,"^P",["^I",[["^K","^Z","^L"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",65,"^E",65,"^S",3,"^T",true,"^H",["^I",["^J",["^I",[["^K","^Z","^L"]]]]]],"~$get-effect",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",35,"^D",7,"^E",35,"^F",17,"^H",["^I",["^J",["^I",[["^K"],["^K","^V"],["^K","^V","~$not-found"]]]]],"~:top-fn",["^ ","^O",false,"^S",3,"^P",["^I",[["^K"],["^K","^V"],["^K","^V","^11"]]],"^H",["^I",[["^K"],["^K","^V"],["^K","^V","^11"]]],"^R",["^I",[null,null,null]]]],"^3","~$re-frame.interceptor/get-effect","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",17,"^12",["^ ","^O",false,"^S",3,"^P",["^I",[["^K"],["^K","^V"],["^K","^V","^11"]]],"^H",["^I",[["^K"],["^K","^V"],["^K","^V","^11"]]],"^R",["^I",[null,null,null]]],"^P",["^I",[["^K"],["^K","^V"],["^K","^V","^11"]]],"^Q",null,"^R",["^I",[null,null,null]],"^D",1,"^C",35,"^E",35,"^S",3,"^T",true,"^H",["^I",[["^K"],["^K","^V"],["^K","^V","^11"]]]],"~$->interceptor",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",19,"^D",7,"^E",19,"^F",20,"^H",["^I",["^J",["^I",[["~$&",["^ ","~:as","~$m","~:keys",["~$name","~$id","~$before","~$after"]]]]]]],"^M","Create an interceptor from named arguements","^12",["^ ","^O",true,"^S",0,"^P",[["^I",[["^ ","^15","~$m","^16",["^17","^18","^19","^1:"]]]]],"^H",["^I",[["~$&",["^ ","^15","~$m","^16",["^17","^18","^19","^1:"]]]]],"^R",["^I",[null]]]],"^3","~$re-frame.interceptor/->interceptor","^O",true,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",20,"^12",["^ ","^O",true,"^S",0,"^P",[["^I",[["^ ","^15","~$m","^16",["^17","^18","^19","^1:"]]]]],"^H",["^I",[["~$&",["^ ","^15","~$m","^16",["^17","^18","^19","^1:"]]]]],"^R",["^I",[null]]],"^P",[["^I",[["^ ","^15","~$m","^16",["^17","^18","^19","^1:"]]]]],"^Q",null,"^R",["^I",[null]],"^D",1,"^C",19,"^E",19,"^S",0,"^T",true,"^H",["^I",[["~$&",["^ ","^15","~$m","^16",["^17","^18","^19","^1:"]]]]],"^M","Create an interceptor from named arguements"],"~$get-coeffect",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",50,"^D",7,"^E",50,"^F",19,"^H",["^I",["^J",["^I",[["^K"],["^K","^V"],["^K","^V","~$not-fount"]]]]],"^12",["^ ","^O",false,"^S",3,"^P",["^I",[["^K"],["^K","^V"],["^K","^V","^1="]]],"^H",["^I",[["^K"],["^K","^V"],["^K","^V","^1="]]],"^R",["^I",[null,null,null]]]],"^3","~$re-frame.interceptor/get-coeffect","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",19,"^12",["^ ","^O",false,"^S",3,"^P",["^I",[["^K"],["^K","^V"],["^K","^V","^1="]]],"^H",["^I",[["^K"],["^K","^V"],["^K","^V","^1="]]],"^R",["^I",[null,null,null]]],"^P",["^I",[["^K"],["^K","^V"],["^K","^V","^1="]]],"^Q",null,"^R",["^I",[null,null,null]],"^D",1,"^C",50,"^E",50,"^S",3,"^T",true,"^H",["^I",[["^K"],["^K","^V"],["^K","^V","^1="]]]],"~$execute",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",146,"^D",7,"^E",146,"^F",14,"^H",["^I",["^J",["^I",[["~$event-v","~$interceptors"]]]]],"^M","Executes the given chain (coll) of interceptors.\n\n   Each interceptor has this form:\n       {:before  (fn [context] ...)     ;; returns possibly modified context\n        :after   (fn [context] ...)}    ;; `identity` would be a noop\n\n   Walks the queue of iterceptors from beginning to end, calling the\n   `:before` fn on each, then reverse direction and walk backwards,\n   calling the `:after` fn on each.\n\n   The last interceptor in the chain presumably wraps an event\n   handler fn. So the overall goal of the process is to \"handle\n   the given event\".\n\n   Thread a `context` through all calls. `context` has this form:\n\n     {:coeffects {:event [:a-query-id :some-param]\n                  :db    <original contents of app-db>}\n      :effects   {:db    <new value for app-db>\n                  :dispatch  [:an-event-id :param1]}\n      :queue     <a collection of further interceptors>\n      :stack     <a collection of interceptors already walked>}\n\n   `context` has `:coeffects` and `:effects` which, if this was a web\n   server, would be somewhat anologous to `request` and `response`\n   respectively.\n\n   `coeffects` will contain data like `event` and the initial\n   state of `db` -  the inputs required by the event handler\n   (sitting presumably on the end of the chain), while handler-returned\n   side effects are put into `:effects` including, but not limited to,\n   new values for `db`.\n\n   The first few interceptors in a chain will likely have `:before`\n   functions which \"prime\" the `context` by adding the event, and\n   the current state of app-db into `:coeffects`. But interceptors can\n   add whatever they want to `:coeffect` - perhaps the event handler needs\n   some information from localstore, or a random number, or access to\n   a DataScript connection.\n\n   Equally, some interceptors in the chain will have `:after` fn\n   which can process the side effects accumulated into `:effects`\n   including but, not limited to, updates to app-db.\n\n   Through both stages (before and after), `context` contains a `:queue`\n   of interceptors yet to be processed, and a `:stack` of interceptors\n   already done.  In advanced cases, these values can be modified by the\n   functions through which the context is threaded."],"^3","~$re-frame.interceptor/execute","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",14,"^P",["^I",[["^1@","^1A"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",146,"^E",146,"^S",2,"^T",true,"^H",["^I",["^J",["^I",[["^1@","^1A"]]]]],"^M","Executes the given chain (coll) of interceptors.\n\n   Each interceptor has this form:\n       {:before  (fn [context] ...)     ;; returns possibly modified context\n        :after   (fn [context] ...)}    ;; `identity` would be a noop\n\n   Walks the queue of iterceptors from beginning to end, calling the\n   `:before` fn on each, then reverse direction and walk backwards,\n   calling the `:after` fn on each.\n\n   The last interceptor in the chain presumably wraps an event\n   handler fn. So the overall goal of the process is to \"handle\n   the given event\".\n\n   Thread a `context` through all calls. `context` has this form:\n\n     {:coeffects {:event [:a-query-id :some-param]\n                  :db    <original contents of app-db>}\n      :effects   {:db    <new value for app-db>\n                  :dispatch  [:an-event-id :param1]}\n      :queue     <a collection of further interceptors>\n      :stack     <a collection of interceptors already walked>}\n\n   `context` has `:coeffects` and `:effects` which, if this was a web\n   server, would be somewhat anologous to `request` and `response`\n   respectively.\n\n   `coeffects` will contain data like `event` and the initial\n   state of `db` -  the inputs required by the event handler\n   (sitting presumably on the end of the chain), while handler-returned\n   side effects are put into `:effects` including, but not limited to,\n   new values for `db`.\n\n   The first few interceptors in a chain will likely have `:before`\n   functions which \"prime\" the `context` by adding the event, and\n   the current state of app-db into `:coeffects`. But interceptors can\n   add whatever they want to `:coeffect` - perhaps the event handler needs\n   some information from localstore, or a random number, or access to\n   a DataScript connection.\n\n   Equally, some interceptors in the chain will have `:after` fn\n   which can process the side effects accumulated into `:effects`\n   including but, not limited to, updates to app-db.\n\n   Through both stages (before and after), `context` contains a `:queue`\n   of interceptors yet to be processed, and a `:stack` of interceptors\n   already done.  In advanced cases, these values can be modified by the\n   functions through which the context is threaded."],"~$assoc-effect",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",44,"^D",7,"^E",44,"^F",19,"^H",["^I",["^J",["^I",[["^K","^V","^W"]]]]]],"^3","~$re-frame.interceptor/assoc-effect","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",19,"^P",["^I",[["^K","^V","^W"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",44,"^E",44,"^S",3,"^T",true,"^H",["^I",["^J",["^I",[["^K","^V","^W"]]]]]],"~$enqueue",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",109,"^D",7,"^E",109,"^F",14,"^H",["^I",["^J",["^I",[["^K","^1A"]]]]],"^M","Add a collection of `interceptors` to the end of `context's` execution `:queue`.\n  Returns the updated `context`.\n\n  In an advanced case, this function would allow an interceptor could add new\n  interceptors to the `:queue` of a context."],"^3","~$re-frame.interceptor/enqueue","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",14,"^P",["^I",[["^K","^1A"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",109,"^E",109,"^S",2,"^T",true,"^H",["^I",["^J",["^I",[["^K","^1A"]]]]],"^M","Add a collection of `interceptors` to the end of `context's` execution `:queue`.\n  Returns the updated `context`.\n\n  In an advanced case, this function would allow an interceptor could add new\n  interceptors to the `:queue` of a context."],"~$mandatory-interceptor-keys",["^ ","^3","~$re-frame.interceptor/mandatory-interceptor-keys","^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",10,"^D",1,"^E",10,"^F",32,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",10,"^D",6,"^E",10,"^F",32]],"~$interceptor?",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",13,"^D",7,"^E",13,"^F",19,"^H",["^I",["^J",["^I",[["~$m"]]]]]],"^3","~$re-frame.interceptor/interceptor?","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",19,"^P",["^I",[["~$m"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",13,"^E",13,"^S",1,"^T",true,"^H",["^I",["^J",["^I",[["~$m"]]]]]],"~$change-direction",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",132,"^D",8,"^E",132,"^F",24,"^G",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Called on completion of `:before` processing, this function prepares/modifies\n   `context` for the backwards sweep of processing in which an interceptor\n   chain's `:after` fns are called.\n\n  At this point in processing, the `:queue` is empty and `:stack` holds all\n  the previously run interceptors. So this function enables the backwards walk\n  by priming `:queue` with what's currently in `:stack`"],"^G",true,"^3","~$re-frame.interceptor/change-direction","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",24,"^P",["^I",[["^K"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",132,"^E",132,"^S",1,"^T",true,"^H",["^I",["^J",["^I",[["^K"]]]]],"^M","Called on completion of `:before` processing, this function prepares/modifies\n   `context` for the backwards sweep of processing in which an interceptor\n   chain's `:after` fns are called.\n\n  At this point in processing, the `:queue` is empty and `:stack` holds all\n  the previously run interceptors. So this function enables the backwards walk\n  by priming `:queue` with what's currently in `:stack`"],"^K",["^ ","^@",null,"^A",["^ ","^B","/mnt/data/Projects/Clojure/7mbookingsystem/resources/public/js/compiled/out/re_frame/interceptor.cljc","^C",121,"^D",8,"^E",121,"^F",15,"^G",true,"^H",["^I",["^J",["^I",[["~$event","^1A"],["^1M","^1A","~$db"]]]]],"^M","Create a fresh context","^12",["^ ","^O",false,"^S",3,"^P",["^I",[["^1M","^1A"],["^1M","^1A","^1N"]]],"^H",["^I",[["^1M","^1A"],["^1M","^1A","^1N"]]],"^R",["^I",[null,null]]]],"^G",true,"^3","~$re-frame.interceptor/context","^O",false,"^B","resources/public/js/compiled/out/re_frame/interceptor.cljc","^F",15,"^12",["^ ","^O",false,"^S",3,"^P",["^I",[["^1M","^1A"],["^1M","^1A","^1N"]]],"^H",["^I",[["^1M","^1A"],["^1M","^1A","^1N"]]],"^R",["^I",[null,null]]],"^P",["^I",[["^1M","^1A"],["^1M","^1A","^1N"]]],"^Q",null,"^R",["^I",[null,null]],"^D",1,"^C",121,"^E",121,"^S",3,"^T",true,"^H",["^I",[["^1M","^1A"],["^1M","^1A","^1N"]]],"^M","Create a fresh context"]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^2",["~:unnamed","~:db","~:queue","~:warn","^3","~:event","~:after","~:id","~:effects","~:stack","~:error","~:coeffects","~:before"]],"~:order",["^1X","^1Y","^22","^3","^1V","^20","^1S","^1Z","^21","^1U","^1[","^1W","^1T"]],"^M",null]